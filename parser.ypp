%{
#include <iostream>
using namespace std;
extern FILE *yyin;
std::string print_format;

int yylex(); 
int yyerror(const char *p) 
{
  if (p != nullptr) {
      std::cout << std::string(p) << '\n'; 
  } else {
      std::cout <<  "Error" << '\n';
  }
  return 1;
}
%}

%code requires { #include "Graph.hpp" }

%union {
    char sym;
    Node *node;
    char* string;
    Graph* graph;
};

%token <sym> IF ELSE WHILE COMMA SEMICOLON LP RP LB RB
%token <node> NUM_LITERAL_D NUM_LITERAL_B IDENTIFIER SKIP MAIN
%token <node> EQUEL OR AND NOT PLUS MINUS TIMES DIV EXP
%token <node> STR_LITERAL COMMENT  
%token <string> OTHER
%nonassoc <node> IS_EQUEL IS_NOT_EQUEL LT GT LT_EQ GT_EQ

%type <graph>  programm
%type <node> func_main func params seq body beq operator caller expr if_ if_else while_
%type <node> t1 t2 t3 t4 t5 t6 t7 t8 


%%

start: programm                             { 
                                              if (print_format == "list") {
                                                  std::cout << "\nGraph:\n";
                                                  print_graph($1->root);
                                              } else if (print_format == "recursively") {
                                                  std::cout << "\nGraph:\n";
                                                  print_graph_recursively($1->root);
                                              } else {
                                                  std::cout << "Unexpected graph output format!\n";
                                              }
                                            }
      
programm: func_main                         { Node *pr = new Node(Messege_type::PROGRAMM, std::vector<Node*>{$1});
                                              $$ = new Graph(pr);  }                                                       
|func programm                              { $2->root->children.push_back($1); $$ = $2; }
|COMMENT programm                           { $2->root->children.push_back($1); $$ = $2; }

func_main: MAIN params body                 { $$ = new Node(Messege_type::FUNC_MAIN, std::vector<Node*>{$1, $2, $3}); }

func: IDENTIFIER params body                { Node* name = new Node(Messege_type::FUNC_NAME, $1->mess);
                                              $$ = new Node(Messege_type::FUNC, std::vector<Node*>{name, $2, $3}); }

params: LP seq RP                           { $$ = new Node(Messege_type::PARAMS, std::vector<Node*>{$2}); }

seq: %empty                                 { $$ = new Node(Messege_type::SEQ); }
| IDENTIFIER                                { $$ = new Node(Messege_type::SEQ, std::vector<Node*>{$1}); }
| IDENTIFIER COMMA seq                      { $$ = new Node(Messege_type::SEQ, std::vector<Node*>{$1, $3}); }

body: LB beq RB                             { $$ = new Node(Messege_type::BODY, std::vector<Node*>{$2}); }
      
beq: operator SEMICOLON                     { $$ = new Node(Messege_type::BEQ, std::vector<Node*>{$1});}
| operator SEMICOLON beq                    { $$ = new Node(Messege_type::BEQ, std::vector<Node*>{$1, $3});}
      
operator: SKIP                              { $$ = new Node(Messege_type::OPERATOR, std::vector<Node*>{$1}); }
| if_                                       { $$ = new Node(Messege_type::OPERATOR, std::vector<Node*>{$1});}
| if_else                                   { $$ = new Node(Messege_type::OPERATOR, std::vector<Node*>{$1});}
| IDENTIFIER EQUEL expr                     { $$ = new Node(Messege_type::OPERATOR, std::vector<Node*>{$1, $2, $3});}
| while_                                    { $$ = new Node(Messege_type::OPERATOR, std::vector<Node*>{$1});}
| caller                                    { $$ = new Node(Messege_type::OPERATOR, std::vector<Node*>{$1});}

if_: IF LP expr RP body                     { $$ = new Node(Messege_type::IF_, std::vector<Node*>{$3, $5});}

if_else: IF LP expr RP body ELSE body       { $$ = new Node(Messege_type::IF_ELSE, std::vector<Node*>{$3, $5, $7});}

while_: WHILE LP expr RP body               { $$ = new Node(Messege_type::WHILE_, std::vector<Node*>{$3, $5});}
  
caller: IDENTIFIER params                   { $$ = new Node(Messege_type::CALLER, std::vector<Node*>{$1, $2});}
  
expr: t1 OR expr                            { $$ = new Node(Messege_type::EXPRESSION, std::vector<Node*>{$1, $2, $3});} 
| t1                                        { $$ = new Node(Messege_type::EXPRESSION, std::vector<Node*>{$1});}
  
t1: t1 AND t2                               { $$ = new Node(Messege_type::T1, std::vector<Node*>{$1, $2, $3});} 
| t2                                        { $$ = new Node(Messege_type::T1, std::vector<Node*>{$1});}
  
t2: NOT t3                                  { $$ = new Node(Messege_type::T2, std::vector<Node*>{$1, $2});} 
| t3                                        { $$ = new Node(Messege_type::T2, std::vector<Node*>{$1});}
  
t3: t4 IS_EQUEL t3                          { $$ = new Node(Messege_type::T3, std::vector<Node*>{$1, $2, $3});} 
| t4 IS_NOT_EQUEL t3                        { $$ = new Node(Messege_type::T3, std::vector<Node*>{$1, $2, $3});} 
| t4 GT t3                                  { $$ = new Node(Messege_type::T3, std::vector<Node*>{$1, $2, $3});} 
| t4 LT t3                                  { $$ = new Node(Messege_type::T3, std::vector<Node*>{$1, $2, $3});} 
| t4 LT_EQ t3                               { $$ = new Node(Messege_type::T3, std::vector<Node*>{$1, $2, $3});} 
| t4 GT_EQ t3                               { $$ = new Node(Messege_type::T3, std::vector<Node*>{$1, $2, $3});} 
| t4                                        { $$ = new Node(Messege_type::T3, std::vector<Node*>{$1});}
  
t4: t5 MINUS t4                             { $$ = new Node(Messege_type::T4, std::vector<Node*>{$1, $2, $3});} 
| t5 PLUS t4                                { $$ = new Node(Messege_type::T4, std::vector<Node*>{$1, $2, $3});} 
| t5                                        { $$ = new Node(Messege_type::T4, std::vector<Node*>{$1});}
  
t5: t6 TIMES t5                             { $$ = new Node(Messege_type::T5, std::vector<Node*>{$1, $2, $3});} 
| t6 DIV t5                                 { $$ = new Node(Messege_type::T5, std::vector<Node*>{$1, $2, $3});} 
| t6                                        { $$ = new Node(Messege_type::T5, std::vector<Node*>{$1});}
  
t6: MINUS t7                                { $$ = new Node(Messege_type::T6, std::vector<Node*>{$1, $2});} 
| t7                                        { $$ = new Node(Messege_type::T6, std::vector<Node*>{$1});}
  
t7: t7 EXP t8                               { $$ = new Node(Messege_type::T3, std::vector<Node*>{$1, $2, $3});} 
| t8                                        { $$ = new Node(Messege_type::T7, std::vector<Node*>{$1});}
  
t8: NUM_LITERAL_D                           {$$ = new Node(Messege_type::T8, std::vector<Node*>{$1});}
| NUM_LITERAL_B                             {$$ = new Node(Messege_type::T8, std::vector<Node*>{$1});}
| STR_LITERAL                               {$$ = new Node(Messege_type::T8, std::vector<Node*>{$1});}
| IDENTIFIER                                {$$ = new Node(Messege_type::T8, std::vector<Node*>{$1});}
| caller                                    {$$ = new Node(Messege_type::T8, std::vector<Node*>{$1});}


%%


int main(int argc, char *argv[])
{
  if (argc != 3) {
    std::cout << "Wrong number of input parameters\n";
    return 1;
  }
  yyin = fopen (argv[1], "r");
  if (!yyin)
  {
    std::cout << "Can't open input file_1\n";
    return 1;
  }
  print_format = std::string(argv[2]);
  int res = yyparse();
  if (res) {
    fclose (yyin);
    return 1;
  }
  fclose (yyin);
  
  return 0;
}
